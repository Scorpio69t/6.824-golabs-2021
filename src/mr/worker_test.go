package mr

import (
	"fmt"
	"strconv"
	"strings"
	"testing"
	"unicode"
)

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
func wcMap(filename string, contents string) []KeyValue {
	// function to detect word separators.
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// split contents into an array of words.
	words := strings.FieldsFunc(contents, ff)

	kva := []KeyValue{}
	for _, w := range words {
		kv := KeyValue{w, "1"}
		kva = append(kva, kv)
	}
	return kva
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
func wcReduce(key string, values []string) string {
	// return the number of occurrences of this word.
	return strconv.Itoa(len(values))
}

//
//  These functions are used to create worker's context
//
func makeContexts() (mapCtxes []*workerContext, reduceCtxes []*workerContext) {
	nReduce := 3
	nMap := 3
	filenames := []string{"pg-being_ernest.txt", "pg-dorian_gray.txt", "pg-frankenstein.txt"}

	for i := 0; i < nMap; i++ {
		mapCtxes = append(mapCtxes, &workerContext{
			currentTask: MRTask{
				Type:   MapType,
				Number: i + 1,
				File:   filenames[i],
				Status: StatusRunning,
			},
			nReduce: nReduce,
			nMap:    nMap,
			mapf:    wcMap,
			reducef: wcReduce,
		})
	}

	for i := 0; i < nReduce; i++ {
		reduceCtxes = append(reduceCtxes, &workerContext{
			currentTask: MRTask{
				Type:   ReduceType,
				Number: i + 1,
				Status: StatusRunning,
			},
			nReduce: nReduce,
			nMap:    nMap,
			mapf:    wcMap,
			reducef: wcReduce,
		})
	}

	return mapCtxes, reduceCtxes
}

//
// End functions for making context
//

func Test_inputFromFile(t *testing.T) {
	ctxes, _ := makeContexts()

	for _, ctx := range ctxes {
		kv, err := inputFromFile(ctx.currentTask.File)
		if err != nil {
			t.Fatal(err)
		}
		fmt.Println(kv.Key)
		fmt.Println(kv.Value)
	}
}

func Test_execMapTask(t *testing.T) {
	ctxes, _ := makeContexts()

	for _, ctx := range ctxes {
		err := execMapTask(ctx)
		if err != nil {
			t.Fatal(err)
		}
	}
}

func Test_inputFromIntermediate(t *testing.T) {
	_, ctxes := makeContexts()

	for _, ctx := range ctxes {
		kva, err := inputFromIntermediate(ctx)
		if err != nil {
			t.Fatal(err)
		}
		fmt.Println(len(kva))
	}
}

func Test_execReduceTask(t *testing.T) {
	_, ctxes := makeContexts()

	for _, ctx := range ctxes {
		err := execReduceTask(ctx)
		if err != nil {
			t.Fatal(err)
		}
	}
}
